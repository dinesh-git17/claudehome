# Epic: Containerized Filesystem Parity & Orchestration

**Epic ID:** E0-INFRA-01

**Phase:** 0 — Local Ecosystem Scaffolding

**Status:** Ready for Implementation

**Last Updated:** 2026-01-15

---

## Epic Description

This epic establishes a hermetic local runtime environment that strictly replicates the production Hetzner VPS filesystem topology. It leverages `docker-compose` to orchestrate a Next.js container context with precise volume mounts, mapping local mock data directories (e.g., `./mocks/thoughts`) to their absolute production counterparts (e.g., `/thoughts`). The work includes implementing strict UID/GID governance to prevent container-host permission mismatches and validating that Node.js `fs` APIs can traverse these simulated system-level paths identically to the production "headless" environment.

**Exit Criteria:** A validated Docker Compose orchestration layer where `pnpm docker:up` builds and starts the Next.js container with all six production filesystem paths mounted, accessible by a non-root process, and verified functional via an automated filesystem access script.

---

## Prerequisites

Before starting this epic:

1. **E0-UI-01 completed OR build-independent** — Either the Tailwind/Turbopack pipeline is established, OR `pnpm build` succeeds without styling dependencies
2. **Node.js 24.11.1** and **pnpm 9.15.0** — As specified in root `package.json`
3. **Docker Engine 24+** — Required for BuildKit and multi-stage build support
4. **Docker Compose v2** — Native `docker compose` CLI (not legacy `docker-compose`)

---

## Governance

### Reference Document

This epic is governed by `CLAUDE.md` at the repository root. All implementation must comply with:

- **Section 1 (Protocol Zero):** No-AI Attribution Policy
- **Section 5.2 (Containerization & Parity):** Volume mount and permission requirements
- **Section 6.2 (Commit Protocol):** Conventional Commits format

### No-AI Attribution Policy

**Enforcement:** Manual review with full artifact scan.

**Reviewers must reject any PR containing:**

- `Co-Authored-By:` headers referencing AI tools (Claude, Copilot, etc.) in commit messages
- "Generated by...", "Created with AI", or similar attributions in PR descriptions
- AI-specific comments, badges, or markers in code comments or file headers
- Robotic or templated language that breaks professional authorship standards

**Policy:** "Invisible Hand" — All code must stand on its own merit, indistinguishable from high-quality human authorship.

---

## Platform Support Matrix

This epic targets cross-platform local development on both macOS and Linux hosts.

| Platform              | Docker Runtime         | UID/GID Strategy                        | Mount Performance                          |
| --------------------- | ---------------------- | --------------------------------------- | ------------------------------------------ |
| macOS (Apple Silicon) | Docker Desktop for Mac | `.env` generation via `id -u`/`id -g`   | VirtioFS (default in Docker Desktop 4.15+) |
| macOS (Intel)         | Docker Desktop for Mac | `.env` generation via `id -u`/`id -g`   | VirtioFS or gRPC-FUSE                      |
| Linux (Ubuntu/Debian) | Docker Engine native   | Direct `${UID}:${GID}` from environment | Native bind mount (fastest)                |

**macOS-Specific Considerations:**

- Docker Desktop for Mac uses VirtioFS by default, providing acceptable bind mount performance
- The `${UID}` and `${GID}` environment variables are not natively set on macOS shells
- A cross-platform `.env` generation script is required (see S-INFRA-03)

---

## Production Filesystem Reference

The following absolute paths exist on the production Hetzner VPS (`157.180.94.145`) and must be simulated locally:

| Production Path | Purpose                    | Mount Mode |
| --------------- | -------------------------- | ---------- |
| `/thoughts`     | Journal entries (markdown) | Read-only  |
| `/dreams`       | Creative experiments       | Read-only  |
| `/sandbox`      | Code experiments           | Read-only  |
| `/projects`     | Long-running work          | Read-only  |
| `/visitors`     | Messages from guests       | Read-only  |
| `/logs`         | Session and cron logs      | Read-only  |

**Rationale for Read-Only:** The web frontend is a read-only consumer of Claude's filesystem. Write operations occur exclusively through the Python runner system. Read-only mounts prevent accidental modification during development and match production semantics.

---

## Stories

### S-INFRA-00: Production-Parity Containerization

**Story Points:** 3

**Description:**
Create the foundational `Dockerfile` for the Next.js application using a multi-stage build pattern. The image must support both development (hot-reload) and production (standalone output) modes. Establish the base image pinning strategy and ensure compatibility with the React Compiler and Turbopack build pipeline.

**Acceptance Criteria:**

| #   | Criterion                                                                                | Verification Method                                      |
| --- | ---------------------------------------------------------------------------------------- | -------------------------------------------------------- | ----------------------------- |
| 1   | `apps/web/Dockerfile` exists with multi-stage build (`deps`, `builder`, `runner` stages) | Code review                                              |
| 2   | Base image is pinned to `node:24.11.1-alpine` or equivalent LTS Alpine variant           | `grep "FROM node" apps/web/Dockerfile`                   |
| 3   | Build stage successfully executes `pnpm build` with Turbopack                            | `docker build --target builder .` exits 0                |
| 4   | Runner stage uses non-root user (`nextjs` or equivalent)                                 | `grep -E "USER                                           | adduser" apps/web/Dockerfile` |
| 5   | Development stage exposes port 3000 and runs `pnpm dev`                                  | Code review of `dev` stage                               |
| 6   | `.dockerignore` exists and excludes `node_modules`, `.next`, `.git`                      | Code review                                              |
| 7   | Image builds successfully on both `linux/amd64` and `linux/arm64`                        | `docker buildx build --platform linux/amd64,linux/arm64` |

**Reference Implementation Notes:**

- Use `corepack enable` to ensure pnpm availability in container
- Copy `pnpm-lock.yaml` before `package.json` for optimal layer caching
- Set `NEXT_TELEMETRY_DISABLED=1` in build environment

---

### S-INFRA-01: Docker Compose Orchestration Baseline

**Story Points:** 2

**Dependencies:**

- S-INFRA-00 completed

**Description:**
Initialize the `docker-compose.yml` scaffolding to define the `web` service context, ensuring it builds from the Dockerfile created in S-INFRA-00. Configure the service to expose standard ports (3000) and define the network topology, establishing the base container runtime for local development.

**Acceptance Criteria:**

| #   | Criterion                                                              | Verification Method                             |
| --- | ---------------------------------------------------------------------- | ----------------------------------------------- |
| 1   | `docker-compose.yml` exists at project root                            | `ls docker-compose.yml`                         |
| 2   | `web` service defined using `build: context: ./apps/web`               | Code review                                     |
| 3   | Port 3000 is correctly forwarded to localhost (`ports: - "3000:3000"`) | Code review                                     |
| 4   | `pnpm docker:up` script added to root `package.json`                   | `grep "docker:up" package.json`                 |
| 5   | `pnpm docker:up` successfully builds and starts the container          | Command exits 0, `curl localhost:3000` responds |
| 6   | `pnpm docker:down` script added to root `package.json`                 | `grep "docker:down" package.json`               |
| 7   | Network `claudehome-net` defined with bridge driver                    | Code review                                     |

**package.json Scripts Addition:**

```json
{
  "scripts": {
    "docker:up": "docker compose up --build -d",
    "docker:down": "docker compose down",
    "docker:logs": "docker compose logs -f web"
  }
}
```

---

### S-INFRA-02: Root-Level Volume Mount Simulation

**Story Points:** 3

**Dependencies:**

- S-INFRA-01 completed

**Description:**
Engineer the volume mount strategy to map local mock directories to absolute system paths inside the container. Create the `./mocks` directory structure for all six production paths and configure `docker-compose.yml` to bind-mount these paths to their production equivalents, forcing the container to perceive them as root-level system directories.

**Acceptance Criteria:**

| #   | Criterion                                                                | Verification Method                                                                     |
| --- | ------------------------------------------------------------------------ | --------------------------------------------------------------------------------------- |
| 1   | `./mocks/` directory structure created with all six subdirectories       | `ls -la ./mocks/` shows `thoughts`, `dreams`, `sandbox`, `projects`, `visitors`, `logs` |
| 2   | Each mock directory contains a sample file for validation                | `ls ./mocks/thoughts/sample.md` (etc.) returns file                                     |
| 3   | `docker-compose.yml` defines volumes mapping all six paths               | Code review shows `./mocks/thoughts:/thoughts:ro` (etc.)                                |
| 4   | `docker exec` into running container confirms `/thoughts` exists at root | `docker exec claudehome-web ls /thoughts` returns files                                 |
| 5   | All six production paths are accessible inside the container             | Verification script (S-INFRA-04) confirms access                                        |
| 6   | Sample files from host are visible inside container at mapped paths      | Manual verification via `docker exec`                                                   |

**Mock Directory Structure:**

```
./mocks/
├── thoughts/
│   └── sample.md          # Minimal markdown: "# Sample Thought\n\nTest entry."
├── dreams/
│   └── sample.md          # Minimal markdown: "# Sample Dream\n\nTest entry."
├── sandbox/
│   └── sample.js          # Minimal JS: "// Sample sandbox file"
├── projects/
│   └── .gitkeep           # Empty placeholder
├── visitors/
│   └── sample.md          # Minimal markdown: "# Visitor Message\n\nHello."
└── logs/
    └── sample.log         # Minimal log: "[2026-01-15] Test log entry"
```

---

### S-INFRA-03: UID/GID Permission Governance

**Story Points:** 5

**Dependencies:**

- S-INFRA-02 completed

**Description:**
Implement strict user permission governance to align the container user with the host developer's UID/GID. Create a cross-platform `.env` generation mechanism that works on both macOS and Linux, ensuring the Node.js process has read access to mounted volumes without requiring root privileges.

**Acceptance Criteria:**

| #   | Criterion                                                                        | Verification Method                                |
| --- | -------------------------------------------------------------------------------- | -------------------------------------------------- |
| 1   | `scripts/generate-env.sh` exists and is executable                               | `ls -la scripts/generate-env.sh` shows `+x`        |
| 2   | Script generates `.env` with `HOST_UID` and `HOST_GID` using `id -u` and `id -g` | Execute script, `cat .env` shows values            |
| 3   | Script works on both macOS (zsh) and Linux (bash)                                | Test on both platforms                             |
| 4   | `docker-compose.yml` references `${HOST_UID}` and `${HOST_GID}` for user mapping | Code review                                        |
| 5   | `.env.example` exists documenting required variables                             | Code review                                        |
| 6   | Container process runs as non-root user                                          | `docker exec claudehome-web ps aux` shows non-root |
| 7   | Node.js process can read files in mapped volumes without `EACCES` errors         | Verification script (S-INFRA-04) passes            |
| 8   | `pnpm docker:up` automatically runs `.env` generation if `.env` is missing       | Code review of script or Makefile                  |

**Cross-Platform .env Generation Script:**

```bash
#!/usr/bin/env bash
# scripts/generate-env.sh
# Generates .env file with host UID/GID for Docker user mapping

set -euo pipefail

ENV_FILE=".env"

echo "HOST_UID=$(id -u)" > "$ENV_FILE"
echo "HOST_GID=$(id -g)" >> "$ENV_FILE"

echo "Generated $ENV_FILE with HOST_UID=$(id -u), HOST_GID=$(id -g)"
```

**docker-compose.yml User Mapping:**

```yaml
services:
  web:
    user: "${HOST_UID}:${HOST_GID}"
```

---

### S-INFRA-04: Turbopack Hot-Reload Validation

**Story Points:** 2

**Dependencies:**

- S-INFRA-03 completed

**Description:**
Validate that Turbopack's hot-reload (HMR) functionality works correctly with Docker bind mounts. Configure any necessary polling or filesystem watching adjustments to ensure file changes on the host trigger rebuilds inside the container within acceptable latency.

**Acceptance Criteria:**

| #   | Criterion                                                                   | Verification Method                                  |
| --- | --------------------------------------------------------------------------- | ---------------------------------------------------- |
| 1   | `pnpm docker:dev` script starts container in development mode               | `grep "docker:dev" package.json`                     |
| 2   | Container runs `pnpm dev --turbopack` (not production build)                | `docker exec claudehome-web ps aux` shows `next dev` |
| 3   | Modifying `apps/web/src/app/page.tsx` on host triggers HMR within 3 seconds | Manual test with timestamp                           |
| 4   | No `ENOENT` or filesystem watching errors in container logs                 | `docker logs claudehome-web` clean                   |
| 5   | `WATCHPACK_POLLING` environment variable set if required for platform       | Code review of docker-compose.yml                    |
| 6   | macOS: HMR latency documented (acceptable threshold: <5s)                   | Manual test, documented in PR                        |
| 7   | Linux: HMR latency documented (acceptable threshold: <2s)                   | Manual test, documented in PR                        |

**package.json Script Addition:**

```json
{
  "scripts": {
    "docker:dev": "docker compose up --build"
  }
}
```

**Potential Environment Variables for HMR:**

```yaml
environment:
  - WATCHPACK_POLLING=true # May be required for macOS
  - CHOKIDAR_USEPOLLING=true # Fallback for older watchers
```

---

### S-INFRA-05: Node.js Filesystem Access Validation

**Story Points:** 2

**Dependencies:**

- S-INFRA-03 completed

**Description:**
Develop a verification script that executes within the container context. This script must use standard `fs.readdir` and `fs.readFile` APIs on all six mounted paths, validating that the application layer can interface with the simulated production filesystem without path traversal issues or permission errors.

**Acceptance Criteria:**

| #   | Criterion                                                            | Verification Method                                                                     |
| --- | -------------------------------------------------------------------- | --------------------------------------------------------------------------------------- |
| 1   | `apps/web/scripts/verify-fs-access.mjs` exists                       | `ls apps/web/scripts/verify-fs-access.mjs`                                              |
| 2   | Script is ES Module (`.mjs`) requiring no TypeScript compilation     | File extension is `.mjs`                                                                |
| 3   | Script validates read access to all six production paths             | Code review shows `/thoughts`, `/dreams`, `/sandbox`, `/projects`, `/visitors`, `/logs` |
| 4   | Script successfully lists files in each directory                    | Execution outputs file listings                                                         |
| 5   | Script reads content from `sample.md` (or equivalent) in `/thoughts` | Execution outputs file content to stdout                                                |
| 6   | Script exits with code 0 on success                                  | `echo $?` returns 0                                                                     |
| 7   | Script exits with code 1 on any `EACCES` or `ENOENT` error           | Deliberate failure test                                                                 |
| 8   | `pnpm docker:verify` script added to root `package.json`             | `grep "docker:verify" package.json`                                                     |

**Verification Script Reference:**

```javascript
// apps/web/scripts/verify-fs-access.mjs
import { readdir, readFile } from "node:fs/promises";

const PRODUCTION_PATHS = [
  "/thoughts",
  "/dreams",
  "/sandbox",
  "/projects",
  "/visitors",
  "/logs",
];

async function verifyPath(path) {
  console.log(`\nVerifying: ${path}`);
  const files = await readdir(path);
  console.log(`  Files: ${files.join(", ") || "(empty)"}`);

  // Attempt to read first file if exists
  if (files.length > 0) {
    const firstFile = `${path}/${files[0]}`;
    const content = await readFile(firstFile, "utf-8");
    console.log(`  Sample content (${files[0]}): ${content.slice(0, 100)}...`);
  }
}

async function main() {
  console.log("=== Filesystem Access Verification ===");

  for (const path of PRODUCTION_PATHS) {
    await verifyPath(path);
  }

  console.log("\n=== All paths verified successfully ===");
}

main().catch((error) => {
  console.error(`\nVERIFICATION FAILED: ${error.message}`);
  process.exit(1);
});
```

**package.json Script Addition:**

```json
{
  "scripts": {
    "docker:verify": "docker exec claudehome-web node /app/scripts/verify-fs-access.mjs"
  }
}
```

---

## Implementation Order

| Order | Story ID   | Story Title                           | Points | Dependencies |
| ----- | ---------- | ------------------------------------- | ------ | ------------ |
| 0     | S-INFRA-00 | Production-Parity Containerization    | 3      | None         |
| 1     | S-INFRA-01 | Docker Compose Orchestration Baseline | 2      | S-INFRA-00   |
| 2     | S-INFRA-02 | Root-Level Volume Mount Simulation    | 3      | S-INFRA-01   |
| 3     | S-INFRA-03 | UID/GID Permission Governance         | 5      | S-INFRA-02   |
| 4     | S-INFRA-04 | Turbopack Hot-Reload Validation       | 2      | S-INFRA-03   |
| 5     | S-INFRA-05 | Node.js Filesystem Access Validation  | 2      | S-INFRA-03   |

**Note:** S-INFRA-04 and S-INFRA-05 can be executed in parallel after S-INFRA-03 completion.

**Total Story Points:** 17

---

## Rollback Procedure

If Docker/volume strategy proves incompatible with the development workflow:

### Strategy: Incremental Rollback with Bisection

1. **Establish Control State:**
   - Remove volume mounts from `docker-compose.yml`
   - Verify container starts and builds without mounts
   - If successful, the issue is mount-related

2. **Bisect — Reduce Mount Complexity:**
   - Mount only `/thoughts` (single path)
   - If successful, add paths incrementally to identify problematic mount

3. **Fallback — Path Aliasing:**
   - If Docker mounts prove unworkable:
   - Implement TypeScript path aliases (`@thoughts/*` → `./mocks/thoughts/*`)
   - Configure `tsconfig.json` paths for local development
   - Use environment variable to switch between Docker and alias modes

4. **Document Findings:**
   - Record which volume/path caused instability
   - Note platform-specific issues (macOS vs Linux)
   - Create follow-up issue for future resolution

---

## Out of Scope

The following are explicitly **not** part of this epic:

- Production deployment to Hetzner VPS
- CI/CD pipeline for Docker builds
- Docker registry push/pull configuration
- Kubernetes/orchestration beyond docker-compose
- Backend API containerization (FastAPI)
- Nginx reverse proxy configuration
- SSL/TLS certificate management
- Multi-container networking beyond single `web` service

---

## Definition of Done

- [ ] All six stories completed with acceptance criteria met
- [ ] `pnpm docker:up` successfully builds and runs the Next.js container
- [ ] All six production filesystem paths mounted and accessible
- [ ] Non-root container process verified
- [ ] Cross-platform UID/GID mapping works on macOS and Linux
- [ ] Turbopack HMR functional inside container
- [ ] Verification script passes with exit code 0
- [ ] No AI attribution in any commits, PRs, or code artifacts
- [ ] PR approved by reviewer following No-AI policy scan (per CLAUDE.md Section 1)

---

## References

- [Docker Volumes vs Bind Mounts vs Compose Watch](https://www.youtube.com/watch?v=u1q8AyNMxd4) — Architectural approach validation
- [Next.js Docker Example](https://github.com/vercel/next.js/tree/canary/examples/with-docker)
- [Docker Compose File Reference](https://docs.docker.com/compose/compose-file/)
- [Docker Desktop for Mac: VirtioFS](https://www.docker.com/blog/speed-boost-achievement-unlocked-on-docker-desktop-4-6-for-mac/)
- [Turbopack with Docker](https://nextjs.org/docs/architecture/turbopack)

---

_This epic is governed by CLAUDE.md. Any conflicts with other documentation are resolved in favor of CLAUDE.md._
